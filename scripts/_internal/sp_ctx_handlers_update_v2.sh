#!/usr/bin/env bash
set -euo pipefail
TARGET="${1:-streetpack_dock.py}"
[[ -f "$TARGET" ]] || { echo "ERR: target not found: $TARGET" >&2; exit 2; }

grep -q "SP_CTX_HANDLERS_CANON_V1" "$TARGET" || { echo "ERR: V1 block not found in $TARGET" >&2; exit 3; }

STAMP="$(date -u +%Y%m%d_%H%M%S_%3NZ 2>/dev/null || date -u +%Y%m%d_%H%M%SZ)"
BAK="${TARGET}.bak.${STAMP}"
cp -a -- "$TARGET" "$BAK"
TMP="${TARGET}.tmp.${STAMP}"

awk '
BEGIN{inblk=0}
# replace the entire V1 block
/^# SP_CTX_HANDLERS_CANON_V1/{
  inblk=1
  print "# SP_CTX_HANDLERS_CANON_V2  (receipts/outputs: open in text editor; right-click menu; debug on failure)"
  print "import os, shutil, subprocess, shlex, sys, re"
  print ""
  print "def _sp_cmd_exists(name: str) -> bool:"
  print "    return shutil.which(name) is not None"
  print ""
  print "def _sp_debug(msg):"
  print "    try: print(msg, file=sys.stderr)"
  print "    except Exception: pass"
  print ""
  print "def _sp_warn(msg):"
  print "    _sp_debug(msg)"
  print "    try:"
  print "        import tkinter.messagebox as mb"
  print "        mb.showwarning(\"StreetPack\", msg)"
  print "    except Exception:"
  print "        pass"
  print ""
  print "def _sp_extract_existing_path(s):"
  print "    if s is None: return None"
  print "    raw = str(s).strip()"
  print "    if raw.startswith(\"file://\"): raw = raw[7:]"
  print "    raw = os.path.expanduser(raw)"
  print ""
  print "    # quick trims for common list formats"
  print "    for sep in (\" â€” \", \" - \", \" | \", \" -> \", \" : \"):"
  print "        if sep in raw:"
  print "            cand = raw.split(sep)[-1].strip()"
  print "            cand = os.path.expanduser(cand)"
  print "            if os.path.exists(cand): return cand"
  print ""
  print "    # exact check"
  print "    if os.path.exists(raw): return raw"
  print ""
  print "    # regex: find a path-looking substring starting with / or ~"
  print "    m = re.search(r\"(~/?[^\\s]+|/[^\\s]+)\", raw)"
  print "    if m:"
  print "        cand = os.path.expanduser(m.group(1)).strip(\"\\\"'()[]{}<>,;\")"
  print "        if os.path.exists(cand): return cand"
  print ""
  print "    # fallback: if there is a / somewhere, take substring to end and strip"
  print "    if \"/\" in raw:"
  print "        cand = raw[raw.find(\"/\"):].strip().strip(\"\\\"'()[]{}<>,;\")"
  print "        if os.path.exists(cand): return cand"
  print ""
  print "    return None"
  print ""
  print "def _sp_value_from_widget_event(event, widget):"
  print "    # Listbox"
  print "    if hasattr(widget, \"nearest\") and hasattr(widget, \"get\"):"
  print "        try:"
  print "            idx = widget.nearest(event.y)"
  print "            try:"
  print "                widget.selection_clear(0, \"end\")"
  print "                widget.selection_set(idx)"
  print "            except Exception:"
  print "                pass"
  print "            return widget.get(idx)"
  print "        except Exception:"
  print "            return None"
  print ""
  print "    # Treeview"
  print "    if hasattr(widget, \"identify_row\") and hasattr(widget, \"item\"):"
  print "        try:"
  print "            row = widget.identify_row(event.y)"
  print "            if not row: return None"
  print "            try: widget.selection_set(row)"
  print "            except Exception: pass"
  print "            item = widget.item(row)"
  print "            v = item.get(\"text\") or \"\""
  print "            if not v and item.get(\"values\"): v = item.get(\"values\")[0]"
  print "            return v"
  print "        except Exception:"
  print "            return None"
  print ""
  print "    return None"
  print ""
  print "def _sp_path_from_widget_event(event, widget):"
  print "    v = _sp_value_from_widget_event(event, widget)"
  print "    p = _sp_extract_existing_path(v) or v"
  print "    return p"
  print ""
  print "def _sp_open_text_editor(path):"
  print "    if not path:"
  print "        _sp_warn(\"No item/path selected.\")"
  print "        return"
  print ""
  print "    raw = str(path).strip()"
  print "    resolved = _sp_extract_existing_path(raw) or os.path.expanduser(raw)"
  print "    _sp_debug(f\"[sp] open_text_editor raw={raw!r} resolved={resolved!r}\")"
  print ""
  print "    if not os.path.exists(resolved):"
  print "        _sp_warn(f\"Path does not exist:\\n{resolved}\")"
  print "        return"
  print ""
  print "    editor = os.environ.get(\"SP_EDITOR\") or os.environ.get(\"EDITOR\")"
  print "    if editor:"
  print "        try:"
  print "            subprocess.Popen(shlex.split(editor) + [resolved])"
  print "            return"
  print "        except Exception as ex:"
  print "            _sp_warn(f\"Failed to run editor: {editor}\\n{ex}\")"
  print "            return"
  print ""
  print "    # common GUI editors"
  print "    for exe, extra in ("
  print "        (\"gnome-text-editor\", []),"
  print "        (\"gedit\", []),"
  print "        (\"code\", [\"--reuse-window\"]),"
  print "        (\"kate\", []),"
  print "        (\"mousepad\", []),"
  print "        (\"xed\", []),"
  print "    ):"
  print "        if _sp_cmd_exists(exe):"
  print "            try:"
  print "                subprocess.Popen([exe] + extra + [resolved])"
  print "                return"
  print "            except Exception as ex:"
  print "                _sp_warn(f\"Failed to launch {exe}:\\n{ex}\")"
  print "                return"
  print ""
  print "    _sp_warn(\"No text editor found. Set SP_EDITOR, e.g.\\nexport SP_EDITOR=\\\"gedit\\\"\")"
  print ""
  print "def _sp_reveal_path(path):"
  print "    if not path:"
  print "        _sp_warn(\"No item/path selected.\")"
  print "        return"
  print ""
  print "    raw = str(path).strip()"
  print "    resolved = _sp_extract_existing_path(raw) or os.path.expanduser(raw)"
  print "    _sp_debug(f\"[sp] reveal raw={raw!r} resolved={resolved!r}\")"
  print ""
  print "    if not os.path.exists(resolved):"
  print "        _sp_warn(f\"Path does not exist:\\n{resolved}\")"
  print "        return"
  print ""
  print "    folder = resolved if os.path.isdir(resolved) else os.path.dirname(resolved)"
  print "    if _sp_cmd_exists(\"xdg-open\"):"
  print "        try:"
  print "            subprocess.Popen([\"xdg-open\", folder])"
  print "            return"
  print "        except Exception as ex:"
  print "            _sp_warn(f\"Failed to open folder:\\n{ex}\")"
  print "            return"
  print "    _sp_warn(\"xdg-open not found; cannot reveal folder.\")"
  print ""
  print "def _sp_copy_path(widget, path):"
  print "    if not path: return"
  print "    try:"
  print "        widget.clipboard_clear()"
  print "        widget.clipboard_append(str(path))"
  print "        widget.update_idletasks()"
  print "    except Exception:"
  print "        pass"
  print ""
  print "def _sp_popup_path_menu(event, widget):"
  print "    try:"
  print "        import tkinter as _tk"
  print "    except Exception:"
  print "        return"
  print "    p = _sp_path_from_widget_event(event, widget)"
  print "    m = getattr(widget, \"_sp_ctx_menu\", None)"
  print "    if m is None:"
  print "        m = _tk.Menu(widget, tearoff=0)"
  print "        widget._sp_ctx_menu = m"
  print "    else:"
  print "        try: m.delete(0, \"end\")"
  print "        except Exception: pass"
  print "    m.add_command(label=\"Open in Text Editor\", command=lambda: _sp_open_text_editor(p))"
  print "    m.add_command(label=\"Reveal in Folder\",  command=lambda: _sp_reveal_path(p))"
  print "    m.add_separator()"
  print "    m.add_command(label=\"Copy Path\",         command=lambda: _sp_copy_path(widget, p))"
  print "    try:"
  print "        m.tk_popup(event.x_root, event.y_root)"
  print "    finally:"
  print "        try: m.grab_release()"
  print "        except Exception: pass"
  print ""
  print "def _sp_open_from_widget(event, widget):"
  print "    p = _sp_path_from_widget_event(event, widget)"
  print "    _sp_open_text_editor(p)"
  print "    return \"break\""
  print "# END SP_CTX_HANDLERS_CANON_V2"
  next
}
inblk==1{
  if ($0 ~ /^# END SP_CTX_HANDLERS_CANON_V1/) { inblk=0 }
  next
}
{ print }
' "$TARGET" > "$TMP"

mv -f -- "$TMP" "$TARGET"
echo "OK: updated handlers to CANON_V2"
echo "Backup: $BAK"
